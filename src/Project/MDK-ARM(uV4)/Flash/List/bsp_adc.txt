; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_adc.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_adc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\ST\STM32F10x -D__UVISION_VERSION=526 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_adc.crf ..\..\User\bsp\src\bsp_adc.c]
                          THUMB

                          AREA ||i.bsp_GetAdc||, CODE, READONLY, ALIGN=2

                  bsp_GetAdc PROC
;;;160    //ch:通道值 0~3
;;;161    u16 bsp_GetAdc(void)
000000  b510              PUSH     {r4,lr}
;;;162    {
;;;163    	//设置指定ADC的规则组通道，一个序列，采样时间
;;;164    	ADC_RegularChannelConfig(ADC1, ADC_Channel_3, 1, ADC_SampleTime_239Cycles5);   //ADC1,ADC通道,采样时间为239.5周期                   
000002  2307              MOVS     r3,#7
000004  2201              MOVS     r2,#1
000006  2103              MOVS     r1,#3
000008  4808              LDR      r0,|L1.44|
00000a  f7fffffe          BL       ADC_RegularChannelConfig
;;;165    
;;;166    	ADC_SoftwareStartConvCmd(ADC1, ENABLE);     //使能指定的ADC1的软件转换启动功能    
00000e  2101              MOVS     r1,#1
000010  4806              LDR      r0,|L1.44|
000012  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;167    
;;;168    	while (!ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC));//等待转换结束
000016  bf00              NOP      
                  |L1.24|
000018  2102              MOVS     r1,#2
00001a  4804              LDR      r0,|L1.44|
00001c  f7fffffe          BL       ADC_GetFlagStatus
000020  2800              CMP      r0,#0
000022  d0f9              BEQ      |L1.24|
;;;169    
;;;170    	return ADC_GetConversionValue(ADC1);    //返回最近一次ADC1规则组的转换结果
000024  4801              LDR      r0,|L1.44|
000026  f7fffffe          BL       ADC_GetConversionValue
;;;171    }
00002a  bd10              POP      {r4,pc}
;;;172    
                          ENDP

                  |L1.44|
                          DCD      0x40012400

                          AREA ||i.bsp_GetAdc_Average||, CODE, READONLY, ALIGN=1

                  bsp_GetAdc_Average PROC
;;;172    
;;;173    u16 bsp_GetAdc_Average(u8 times)
000000  b570              PUSH     {r4-r6,lr}
;;;174    {
000002  4604              MOV      r4,r0
;;;175    	u32 temp_val = 0;
000004  2500              MOVS     r5,#0
;;;176    	u8 t;
;;;177    	for (t = 0; t < times; t++)
000006  2600              MOVS     r6,#0
000008  e007              B        |L2.26|
                  |L2.10|
;;;178    	{
;;;179    		temp_val += bsp_GetAdc();
00000a  f7fffffe          BL       bsp_GetAdc
00000e  4405              ADD      r5,r5,r0
;;;180    		bsp_DelayMS(5);
000010  2005              MOVS     r0,#5
000012  f7fffffe          BL       bsp_DelayMS
000016  1c70              ADDS     r0,r6,#1              ;177
000018  b2c6              UXTB     r6,r0                 ;177
                  |L2.26|
00001a  42a6              CMP      r6,r4                 ;177
00001c  dbf5              BLT      |L2.10|
;;;181    	}
;;;182    	return temp_val / times;
00001e  fbb5f0f4          UDIV     r0,r5,r4
000022  b280              UXTH     r0,r0
;;;183    }
000024  bd70              POP      {r4-r6,pc}
;;;184    
                          ENDP


                          AREA ||i.bsp_InitAdc||, CODE, READONLY, ALIGN=2

                  bsp_InitAdc PROC
;;;119    
;;;120    void  bsp_InitAdc(void)
000000  b500              PUSH     {lr}
;;;121    {
000002  b087              SUB      sp,sp,#0x1c
;;;122    	ADC_InitTypeDef ADC_InitStructure;
;;;123    	GPIO_InitTypeDef GPIO_InitStructure;
;;;124    
;;;125    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_ADC1, ENABLE);   //使能ADC1通道时钟
000004  2101              MOVS     r1,#1
000006  f44f7001          MOV      r0,#0x204
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;126    
;;;127    
;;;128    	RCC_ADCCLKConfig(RCC_PCLK2_Div6);   //设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M
00000e  f44f4000          MOV      r0,#0x8000
000012  f7fffffe          BL       RCC_ADCCLKConfig
;;;129    
;;;130    	//PA1 作为模拟通道输入引脚                         
;;;131    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
000016  2008              MOVS     r0,#8
000018  f8ad0004          STRH     r0,[sp,#4]
;;;132    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;       //模拟输入引脚
00001c  2000              MOVS     r0,#0
00001e  f88d0007          STRB     r0,[sp,#7]
;;;133    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000022  a901              ADD      r1,sp,#4
000024  4817              LDR      r0,|L3.132|
000026  f7fffffe          BL       GPIO_Init
;;;134    
;;;135    	ADC_DeInit(ADC1);  //复位ADC1,将外设 ADC1 的全部寄存器重设为缺省值
00002a  4817              LDR      r0,|L3.136|
00002c  f7fffffe          BL       ADC_DeInit
;;;136    
;;;137    	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;  //ADC工作模式:ADC1和ADC2工作在独立模式
000030  2000              MOVS     r0,#0
000032  9002              STR      r0,[sp,#8]
;;;138    	ADC_InitStructure.ADC_ScanConvMode = DISABLE;   //模数转换工作在单通道模式
000034  f88d000c          STRB     r0,[sp,#0xc]
;;;139    	ADC_InitStructure.ADC_ContinuousConvMode = DISABLE; //模数转换工作在单次转换模式
000038  f88d000d          STRB     r0,[sp,#0xd]
;;;140    	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; //转换由软件而不是外部触发启动
00003c  f44f2060          MOV      r0,#0xe0000
000040  9004              STR      r0,[sp,#0x10]
;;;141    	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;  //ADC数据右对齐
000042  2000              MOVS     r0,#0
000044  9005              STR      r0,[sp,#0x14]
;;;142    	ADC_InitStructure.ADC_NbrOfChannel = 1; //顺序进行规则转换的ADC通道的数目
000046  2001              MOVS     r0,#1
000048  f88d0018          STRB     r0,[sp,#0x18]
;;;143    	ADC_Init(ADC1, &ADC_InitStructure); //根据ADC_InitStruct中指定的参数初始化外设ADCx的寄存器   
00004c  a902              ADD      r1,sp,#8
00004e  480e              LDR      r0,|L3.136|
000050  f7fffffe          BL       ADC_Init
;;;144    
;;;145    
;;;146    	ADC_Cmd(ADC1, ENABLE);  //使能指定的ADC1
000054  2101              MOVS     r1,#1
000056  480c              LDR      r0,|L3.136|
000058  f7fffffe          BL       ADC_Cmd
;;;147    
;;;148    	ADC_ResetCalibration(ADC1); //使能复位校准  
00005c  480a              LDR      r0,|L3.136|
00005e  f7fffffe          BL       ADC_ResetCalibration
;;;149    
;;;150    	while (ADC_GetResetCalibrationStatus(ADC1)); //等待复位校准结束
000062  bf00              NOP      
                  |L3.100|
000064  4808              LDR      r0,|L3.136|
000066  f7fffffe          BL       ADC_GetResetCalibrationStatus
00006a  2800              CMP      r0,#0
00006c  d1fa              BNE      |L3.100|
;;;151    
;;;152    	ADC_StartCalibration(ADC1);  //开启AD校准
00006e  4806              LDR      r0,|L3.136|
000070  f7fffffe          BL       ADC_StartCalibration
;;;153    
;;;154    	while (ADC_GetCalibrationStatus(ADC1));   //等待校准结束
000074  bf00              NOP      
                  |L3.118|
000076  4804              LDR      r0,|L3.136|
000078  f7fffffe          BL       ADC_GetCalibrationStatus
00007c  2800              CMP      r0,#0
00007e  d1fa              BNE      |L3.118|
;;;155    
;;;156    //  ADC_SoftwareStartConvCmd(ADC1, ENABLE);     //使能指定的ADC1的软件转换启动功能
;;;157    
;;;158    }
000080  b007              ADD      sp,sp,#0x1c
000082  bd00              POP      {pc}
;;;159    //获得ADC值
                          ENDP

                  |L3.132|
                          DCD      0x40010800
                  |L3.136|
                          DCD      0x40012400

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_adc_c_358487f0____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_bsp_adc_c_358487f0____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_adc_c_358487f0____REVSH|
#line 128
|__asm___9_bsp_adc_c_358487f0____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
